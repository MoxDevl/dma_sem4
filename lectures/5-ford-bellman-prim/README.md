# Поиск путей и минимальное остовное дерево

## Алгоритм Форда-Беллмана

У алгоритма Дейкстры, который мы рассмотрели на прошлой лекции, есть как сильные стороны, так и слабые.

Сильная сторона - он быстро работает, а именно за O(|E|*log(|V|)) (если использовать кучу для поиска минимума)

Салбая - он не даёт корректный ответ для графов с отрицательными циклами.

Рассмотрим следующий граф:

<img width="717" alt="image" src="https://github.com/user-attachments/assets/2c2e4b3b-4d98-4413-983e-6992eba9d0b6" />

Он имеет отрицательный цикл 1 - 2 - 3 - 1, суммарный вес такого цикла = -80

Если попробуем найти кратчайшее расстояние от 1 до любой другой вершины - получим -∞ (можем бесконечно много раз проходить по циклу и уменьшать расстояние).

Будем считать бесконечное расстояние неопределённым.

Алгоритм Дейкстры для этого графа вернёт конкретный результат (d = [-80, 10, 20]), что не является верным резултатом.

Задачу поиска минимального пути в графе с отрицательными весами позволяет решить алгоритм **Форда-Беллмана**

Этот алгоритм тоже создаёт массив расстояний, в котором хранит расстояния от начальной вершины до каждой другой, и так же проводит релаксацию рёбер, как алгоритм Дейкстры, но обработка вершин отличается.

* Задаём начальную иконечную вершину: S и F
* Создаём массив расстояний d от начальной вершины 5 до всех других
* d[S] = 0, для остальных - +∞
* Выполняем |V| - 1 итераций:
* Для каждого ребра u - v с весом w:
    * Если d[v] > d[u] + w, обновляем d[v] = d[u]+w.

Вот и всё!

Получается даже легче, чем Дейкстра, потому что мы на каждой итерации проходимся по всем рёбрам графа.

Как такой алгоритм будет работать на нашем графе?

Проинициализировали переменные:

<img width="1218" alt="image" src="https://github.com/user-attachments/assets/6644b8da-470f-4e98-ac37-ad1e7875f62d" />

Предположим, что сначала мы пройдёмся по ребру 1 - 2, улучшаем ответ
<img width="1203" alt="image" src="https://github.com/user-attachments/assets/162b5ef7-9c98-418b-b7eb-9b1eb70fc1ef" />

Дальше - по 2 - 3, тоже обновляем результат
<img width="1215" alt="image" src="https://github.com/user-attachments/assets/5d3cde6a-453f-406a-8f2c-cb13fb9e4a4b" />

3 - 1, обновляем результат. Первая итерация закончилась, потому что мы прошлись по всем рёбрам
<img width="1200" alt="image" src="https://github.com/user-attachments/assets/37828ec9-7526-4b68-aecd-219861f05d8b" />

Начинается вторая (и она же последняя) итерация:
<img width="1203" alt="image" src="https://github.com/user-attachments/assets/5e9d0e6c-3a2f-4130-96ff-72ddcad535f2" />

<img width="1187" alt="image" src="https://github.com/user-attachments/assets/598b62b8-2f19-4eab-a5cc-ccc16e05ac3b" />

<img width="1199" alt="image" src="https://github.com/user-attachments/assets/5e56f6c0-3022-47d3-b9b6-edc4b72e3406" />

<img width="1203" alt="image" src="https://github.com/user-attachments/assets/e5ebd3bf-fba3-4fb3-be91-fc0c009c021a" />

<img width="1201" alt="image" src="https://github.com/user-attachments/assets/848486dc-5208-42e7-9b2d-8bf58c0c6146" />

Супер! Получили результат. Хоть ситуация и лучше, чем в Дейкстре, но опять же мы получили конкретные результаты, а не "неопределено", что делать?

На самом деле всё просто! Попробуем опять провести релаксацию всех рёбер, и если у нас улучшился результат, у нас есть отрицательный цикл.

Если результат нашей конечной вершины тоже изменился, то расстояние до неё не определено.

Мы научились получать минимальное расстояние. Как нам получить сам путь?

Для этого будем хранить не просто расстояние от 5 до всех других вершин, а матрицу А, где A [i][j] - это длина кратчайшего пути из S в і, содержащего не более j рёбер, а также матрицу Р, где Р[i][j] - вершина, из которой мы попали в і в пути из j рёбер.

Тогда алгоритм будет выглядеть примерно следующим образом:
```
for v in V:
  for i in range(|V|):
    A[V][i]= tinf
A[s][0] = 0
for i in range(1, |V|):
  for (from, to, w) in E:
    if A[to][i] > A[from][i - 1] + w:
      A[to][i] = A[from][i - 1] + w
```

Получив Р, можем восстановить ответ (тут предполагается, что получаем путь от S до і):

```
res = []
while j > 0:
  res.append(i)
  i = P[i][j]
  j -= 1
```

В итоге в res имеем путь в обратном порядке. Перевернём его, и получим наш результат.

## Минимальное остовное дерево

Дерево - связный граф, в котором нет циклов. Из каждого связного графа мы можем сделать дерево, если будем удалять рёбра так, чтобы в итоге получилось |V| - 1 ребро.

Минимальное остовное дерево графа - это дерево, которое получается из заданного графа удалением рёбер таким образом, что сумма весов рёбер полученного дерева минимальна.

Пример:

<img width="1260" alt="image" src="https://github.com/user-attachments/assets/e2227cae-7d51-424a-89fd-9698a2c0a044" />

(Вместо ребра 2-4 могли взять ребро 2-3 и получили бы тот же результат: 4)

Вы уже знаете алгоритм Краскала (Крускала), так что разберём алгоритм Прима.

* Выберем стартовую вершину S
* Создадим множество visited и приоритетную очередь (min-heap) для хранения рёбер
* Пока очередь не пуста:
    * Извлекаем ребро с минимальным весом
    * Если вершина не посещена, добавляем её в ответ и добавляем в очередь её соседей с весом ребра. Иначе - игнорируем вершину

Как это выглядит на практике?

<img width="1227" alt="image" src="https://github.com/user-attachments/assets/34be3fee-69e8-4fdf-be14-1d1bba8fe017" />

<img width="1225" alt="image" src="https://github.com/user-attachments/assets/6bc4e96d-3c21-416c-9356-2651e534e756" />

<img width="1212" alt="image" src="https://github.com/user-attachments/assets/1bd9e6b3-c810-4ddf-81ce-4f252727cf36" />

<img width="1201" alt="image" src="https://github.com/user-attachments/assets/d43dab4d-d383-4ee4-81c9-7c4e622f1acd" />

<img width="1219" alt="image" src="https://github.com/user-attachments/assets/5bd59f67-fc15-42b1-9a96-634bbe03423e" />

То есть на каждой обработке вершины, мы добавляем кортеж из его веса ребра до его соседа и самого соседа.

Код выглядит примерно следующим образом:

```python
import heapq
def prim(graph, start):
  visited = set()
  heap = [(0, start)] m s t = []
  while heap:
    weight, u= heapq.heappop(heap)
    if u not in visited:
      visited.add(u)
      mst.append((u, weight))
      for v, w in graph[u]:
        if v not in visited:
        heapq.heappush(heap, (w, v))
  return mst
```
